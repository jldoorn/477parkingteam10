<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, posted on Brightspace.  

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->
<base href="https://engineering.purdue.edu/477grp10/" /> <!-- Replace the N with your team number-->
<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Jonthan Doorn</h2>

			<h4>Spring Break and Week 10:</h4>
            <b>Date:</b> Friday, March 24, 2023<br>
            <b>Total hours:</b> 8<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Integrated Seven Segment display code</li>
				<li>Developed a distance debugging mode for testing</li>
			</ul>
			
Over the past week, I integrated some of Fred's seven segment display code to 
display parking garage capacity on the two large seven segment displays that our
AM will use. The seven segment displays are attached to display drivers, controlled by
a set of shift registers. These shift registers contain the state for each segment of the 
two displays and can be written to using the SPI protocol. We have two large displays, which 
means that a signle 16-bit SPI write can update the displayed value in a range from 00 to 99.
Attached below are figures demonstrating the integration of this new display.
<br><br>
Additionally, I made a modificaiton to the CDM codebase that will display the distance reading from
the proximity sensor in a continuous loop. This will be used when we take the device into 
a parking garage for on site testing this weekend.
			<h5>Figures</h5> 
			  <div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/sevensegmentint.jpeg"></img><br>
				<b>Figure 18:</b> Prototype with large seven segment displays showing current garage capacity
			</div>
			  <br><br>

			<h4>Weeks 8-9:</h4>
            <b>Date:</b> Friday, March 10, 2023<br>
            <b>Total hours:</b> 15<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Integrated proximity debouncer into CDM flow event trigger system</li>
				<li>Rewrote timer interrupts to reduce critical section time</li>
			</ul>
			<h5>Reporting Efforts</h5>
			<ul>
				<li>Produced Prototyping, Software, and Project Timeline slides for design review</li>
				<li>Peer reviewed two design review presentations</li>
			</ul>

			<h5>Week 8 Contributions</h5>
Prepared slides for the Design Review presentation. I aggregated diagrams pertaining to our prototypes 
and software progress to produce visuals used in our design review. I also looked through the 
syllabus to find important deadlines for the remaining weeks in the semester in order to populate 
our GANTT chart. In addition to the deadlines, I scoped out milestones for software progress through 
the end of the project to keep the team on track in development. See the attached figure for our project timeline. 
<br><br>
Before our design review, I met with the other team members to run through our presentation and put in finishing touches. 
Our design review occurred on Thursday afternoon, and then Friday morning I was a peer reviewer for two other teams.

			<h5>Week 9 Contributions</h5>
			
			Following the timeline, I implemented the functionality of car detection via proximity sensor measurement
			 to our prototype. With the modifications, the proximity sensor is integrated with CDM code in triggering 
			 inflow and outflow measurements. I took extra precautions to debounce the proximity measurements and produce 
			 one-off triggers such that a single car entry will produce a single modification to overall garage capacity.
			 <br><br>

			 In implementing this functionality, I created a timer interrupt to go off at a frequency of 100Hz. Originally, 
			 on interrupt, I directly triggered a proximity measurement and debounce. This by itself was enough to detect car 
			 trigger state, however once I integrated the rest of the CDM features, namely transmission of trigger events over 
			 the Wi-Fi connection to the AM, the functionality broke. On transmission of a trigger event, the CDM would freeze. 
			 On further inspection, the reason for the freeze was due to the timer interrupt occurring too frequently and taking 
			 too many clock cycles to handle. The timer interrupt would not finish in time for the UART interrupt to buffer incoming data. 

			 <br><br>

			 I overcame this hurdle by moving the work necessitated by the interrupt into the main loop, where the interrupt 
			 handler sets a flag which is then checked and reset by a routine in main, which can be interrupted when there is 
			 pending data on the UART RX line. After making this modification, I was able to demonstrate the ability of simulating 
			 car entry and exit by moving my hand in front of the proximity sensor on the CDM and seeing single updates in capacity
			  occur on the AM's capacity display. See the attached figure showcasing the setup of this demonstration.
			  <h5>Figures</h5> 
			  <div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/projecttimeline.png"></img><br>
				<b>Figure 16:</b> Project timeline from design review presentation
			</div>
			<br><br>
			  <div style="margin: auto; text-align: center; ">
				  <img style="width: 50%; border: solid;" src="Team/progress/img/jon/ProxTriggerDemo.jpeg"></img><br>
				  <b>Figure 17:</b> CDM to AM flow demo setup where triggers are caused by a stream of close proximity measurements
			  </div>
			  <br><br>
			<h4>Week 7:</h4>
            <b>Date:</b> Friday, February 24, 2023<br>
            <b>Total hours:</b> 9<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Implemented proximity debouncer for CDM</li>
				<li>Researched gated timers for better proximity precision</li>
				<li>Integrated Fred's keypad and LCD code from a capacity demo into the main codebase</li>
				<li>Prepared flow demo with CDM to AM communication</li>
			</ul>
			The first task for this week's design efforts was architecting a debouncer
			to handle proximity sensor measurements that the team is able to acquire. 
			The concept to trigger a flow event for our parking system is to collect 
			proximity measurements periodically, and once the distance measured stays under
			a threshold for a given amount of time, consider it to be a flow event. 
			A flow event should not be reported more than once for a stream of low distance
			measurements.
			<br><br>
			I implemented this debouncer design by creating a ring buffer where new proximity measurements
			are stored. Upon storing a new measurement in the buffer, if all buffer elements are under a
			distance threshold, a trigger flag is set. The trigger flag is reset once the trigger has been read
			and all the distance measurements in the buffer rise back above the triggering threshold.
			<br><br>
			I also spent time researching more resource efficient ways of collecting distance measurements
			from the proximity sensor. A measurement from the sensor can be obtained by triggering the 
			sensor for 10us, then measuring the amount of time the sensor's measurement pin stays high. Currently,
			the triggering is performed by busy waiting in the measurement function, and a microsecond timer
			is started once the sensor's measurement pin goes high. The timer increments a global variable every
			interrupt, and once the sensor's measurement pin drops, the timer is stopped and the global microsecond
			count is read.
			<br><br>
			An alternative to this method could be to configure a timer in gated slave mode, where a trigger pin
			controls the enable state of the timer's counter. Upon triggering the proximity sensor, the gated 
			timer's counter register could be reset, and an interrupt after the measurement pin goes low could
			read the gated timer's counter register, and place the distance measurement in the debouncer's ring buffer.
			<br><br>
			Finally, I integrated Fred's keypad and display code from a demo he produced for AM initialization into 
			the main codebase. This step was the last component needed to produce a demo of the entire flow of 
			parking system operation. I finished off this demo by writing CDM code to send flow events when 
			buttons were pressed.
			<br><br>
			The flow of this demo is as followed, and shown in figures 14 and 15:
			<ol>
				<li>Power on AM</li>
				<li>Enter number of free spaces on AM</li>
				<li>Power on CDM</li>
				<li>Wait for CDM to indicate that Wifi has been connected</li>
				<li>Press CDM button to send an inflow update, observe AM count decreases</li>
				<li>Press CDM button to send an outflow update, observe AM count increases</li>
			</ol>

			<h5>Figures</h5> 
			<div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/am_flow.jpeg"></img><br>
				<b>Figure 14:</b> AM flow demo setup indicating garage capacity on LCD display
			</div>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/cdm_flow.jpeg"></img><br>
				<b>Figure 15:</b> CDM flow demo setup with button-triggered flow events and debug LCD display
			</div>
            <br>


			<h4>Week 6:</h4>
            <b>Date:</b> Friday, February 17, 2023<br>
            <b>Total hours:</b> 12<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Integrated proximity sensor code into main codebase</li>
				<li>Created flowcharts for direction detection from a pair of proximity sensors at each CDM</li>
				<li>Prepared demo transmitting proximity sensor data over Wifi network</li>
			</ul>
			<h5>Reporting efforts</h5>
			<ul>
				<li>Prepared Software Formalization </li>
			</ul>

			The first task I took on this week was to import the proximity sensor code which Aaron had developed into 
			the codebase containing the wifi demos. There were some pin conflicts between the two projects, which I 
			corrected within STM32CubeMX. The current pinout of our microcontroller can be seen in figure 13. Additionally,
			I discovered that the distance measurements on my microcontroller were not consistent with the distance measurements
			from the demo running on Aaron's microcontroller. This is because the operation of the proximity sensor relies on 
			measuring the elapsed time from a proximity sensor trigger to the time the proximity sensor hears the echo from its trigger.
			The clock on Aaron's microcontroller was set to 48MHz, while the clock on the microcontroller I had been using for 
			Wifi demos was set to 8MHz. This resulted in shorter distances being reported on my microcontroller. Once I adjusted
			the timer handlers to configure the timers to count microseconds from an 8MHz clock signal, the demo behaved as expected.

			<br><br>
			Additionally, I produced in-depth flowcharts of the interrupt handlers that have been used in the demos so far, 
			and extended these flowcharts to include a method to handle proximity sensor data from the CDM and later its slave module
			to produce API messages indicating the direction of travel of vehicles passing through the entrance where each
			CDM is installed. Flowcharts indicating the necessary manipulation of global state variables to produce a 
			flow message can be found in figures 11 and 12.

			<br><br>
			I also spent a couple hours helping Fred integrate his keypad code into the main codebase and navigate pin conflicts that
			overlapped with the UART which the wifi modules are attached. We were able to use STM32CubeMX to quickly initialize a timer
			and GPIO pins suitable for the reading of input from a pinpad. This was one of the final integrations necessary to 
			enable a full system prototype. The final touch will be the seven-segment display module. Until then, we will be able
			to create a demo of our system using a small LCD display for both AM configuration and to display free parking spots.

			<br><br>
			Finally, I prepared several block diagrams detailing the architecture of the codebase for our parking tracking system, which
			will be used in the Software Formalization report. A high level overview of the software progress so far can be seen in 
			figure 10.

			<h5>Figures</h5> 
			<div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/program_blocks.png"></img><br>
				<b>Figure 10:</b> High level formal block diagram, each subset is broken out in further detail in the Software Formalization report
			</div>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/CDMHandlers.png"></img><br>
				<b>Figure 11:</b> Flowcharts indicating how data is handled from peripheral interupts
			</div>
            <br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/slavehandler.png"></img><br>
				<b>Figure 12:</b> Routine to be run when a message is received from the CDM's slave module
			</div>
            <br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/cubemx_after_pinpad.png"></img><br>
				<b>Figure 13:</b> Pinout after integration of proximity sensor and keypad into the main codebase
			</div>
            <br>

			<h4>Week 5:</h4>
            <b>Date:</b> Friday, February 10, 2023<br>
            <b>Total hours:</b> 8<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Prepared demo of bidirectional messaging between two STM32F0 microcontrollers</li>
				<li>Modified wifi driver to be more stable and require less codebase tweaking for install.</li>
				<li>Planned for week 6 demo goals</li>
			</ul>
			<h5>Reporting efforts</h5>
			<ul>
				<li>Reviewed Bill of Materials for connectivity components</li>
			</ul>
			

			The first step this week was to stabilize our wifi module driver codebase to the point that under any circumstance, a micro
			using a wifi module could reset and re-initialize the wifi module on bootup. Measuring the time to configure connectivity,
			the aggregator module (AM) (hosting the wifi accesspoint) is able to configure itself in under 0.5 seconds on bootup. The Car Detector Module (CDM), 
			once the AM is powered on and configured, is able to connect to the access point of the AM in roughly one second and acquire an IP
			address.
			<br><br>
			The demo code initializes the wifi modules for the AM and CDM, then enters a loop where
			<ol>
				<li>If there is data waiting from the Wifi module, handle it and print the waiting message</li>
				<li>If there is data waiting on the debug UART, assume the User is trying to send a message, acquire a line up to a Linefeed character, then send to the other module on the wifi link</li>
			</ol>
			with this setup, it appears as if the two modules have an instance of a bare-bones instant messaging application running between them.

			<br><br>
			This successful demonstration lays the groundwork for our next goal, which is to bring proximity data into the network. 
			The next step will be to connect a display to the AM, and increment a number shown on the display based on messages
			received from the CDMs connected to the AM's access point. I have begun to implement the data structures necessary to 
			accomplish this. Once the handling of increment (decrement) messages has been demonstrated successfully, we can move the 
			trigger for these messages to be based on the readings from the proximity sensor on our CDMs. At this point, our prototype should
			be complete and ready for design review.
			<br><br>
			Finally, for administrative tasks,  I reviewed the Bill of Materials and added the wifi module part that the team has been using until now.
			Additionally, I configured a branch in our git repository to track changes made to our team website, which will make it easier to 
			roll back changes if files are unintentionally modified or deleted. 

			<h4>Week 4:</h4>
            <b>Date:</b> Friday, February 3, 2023<br>
            <b>Total hours:</b> 15<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Migrated Wifi module driver code from Python prototype to embedded c</li>
				<li>Setup development environment for microcontroller in STM32CubeIDE</li>
				<li>Wrote interrupt handlers to buffer UART data, utility functions to streamline UART IO interractions</li>
				<li>Conducted max current draw testing on Wifi chips in idle, transmit, and receive modes</li>
			</ul>
			<h5>Reporting efforts</h5>
			<ul>
				<li>Completed component analysis for radio module </li>
			</ul>
			

			My first accomplishment this week was seting up a codebase to handle uart traffic on the 
			STM32 microcontroller. I first created a fifo buffer API, then initialized fifo buffers to 
			collect incoming UART traffic. I set up interrupt handlers to push RX UART data into the 
			buffers. I then wrote utilities to handle reading from these buffers, for example, routines
			to block and read from a buffer until a specified character is seen, and a blocking read until
			a given number of bytes are read.
			<br><br>
			With these utilities, I was able to write a response handler to block on traffic from the 
			Wifi modules, then parse into received packet data and module status updates. I also wrote initialization
			routines for the Wifi module, sending commands necessary for creating a Wifi access point and 
			accepting UDP packets, and checking module responses for success in between commands.
			<br><br>
			I then put together two tests, one for mass packet reception, and one for mass packet transmission between
			Wifi modules. I measured the current drawn by the modules during these tests to include in the component 
			analysis report. 
			<br><br>
			<h5>Figures</h5> 
			<div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/wifi_driver_arch.png"></img><br>
				<b>Figure 6:</b> Wifi driver architecture
			</div>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/wifi_test.jpg"></img><br>
				<b>Figure 7:</b> Breadboard setup for wifi current draw test
			</div>
            <br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/uart_rx_handler.png"></img><br>
				<b>Figure 8:</b> UART RX Interrupt Handler
			</div>
            <br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/wifi_control_seq.png"></img><br>
				<b>Figure 9:</b> Wifi Driver Control Sequence
			</div>
            <br>

			<h5>Citations</h5> 
			<ul>
				<li>
					https://espressif-docs.readthedocs-hosted.com/projects/esp-at/en/release-v2.2.0.0_esp32/AT_Command_Set/Basic_AT_Commands.html
				</li>
			</ul>


			<h4>Week 3:</h4>
            <b>Date:</b> Wednesday, January 25, 2023<br>
            <b>Total hours:</b> 11<br>
            <b>Description of project design efforts:</b><br>
			<h5>Designing efforts</h5>
			<ul>
				<li>Designed an UDP API to communicate events between CDMs and the AM (Figure 3)</li>
				<li>Implemented this API in Python and performed simulations (Figure 4)</li>
				<li>Flashed firmware to wifi modules</li>
				<li>Created a demo for wifi connectivity in Python showcasing UDP API functionality (Figure 5)</li>
			</ul>

			In terms of demos and prototypes, the first step was creating a demo to run on UDP between two open 
			ports local to my laptop. I had to research how to open UNIX sockets with python to accomplish this.
			Following my research of python sockets, I also created python serializers and deserializers for the API
			I designed. Once I was able to simulate events locally, I then created an interface to work with the UART
			wifi modules that will be used in our deliverable.
			<br><br>
			In order to create this interface, I utilized the AT Command documentation for the ESP-01 wifi module based
			on the ESP 8266 Wifi MCU. Essentially, I made a routine to set up a wifi network, then transitioned into an infinite loop
			that parsed messages from the Wifi modem, separating incoming data from status messages. I envision a similar event
			handler on the final product, however the handler on our micro will not run continuously, only when there is data waiting
			from our Wifi modem.
			<br><br>
			I verified that I was getting the same results using the UART wifi modules as I was getting with the localhost UDP simulation.
			<h5>Figures</h5> 
			<div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/apispec.jpg"></img><br>
				<b>Figure 3:</b> Hand drawn API specification
			</div>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/udp_git_hist.png"></img><br>
				<b>Figure 4:</b> GitHub commit history for API prototyping
			</div>
            <br>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/udp_sim_sc.jpg"></img><br>
				<b>Figure 5:</b> Output of UDP simulation
			</div>
            <br>

			<h5>Citations</h5> 


            
            <h4>Weeks 1-2:</h4>
            <b>Date:</b> Friday, January 20, 2023<br>
            <b>Total hours:</b> 8<br>
            <b>Description of project design efforts:</b><br>
            I will break down my project efforts into two categories, and leave figures at the end of each report
			
			<h5>Reporting efforts</h5>
			<ul>
				<li>Edited project website to include my bio and position information</li>
				<li>Added my responsibilities to final project proposal</li>
				<li>Proofread final project proposal</li>
				<li>Produced block diagram for Functional Specification (Figure 1)</li>
				<li>Completed "Expected Usage Case" section of Functional Specification</li>
			</ul>
			<h5>Designing efforts</h5>
			<ul>
				<li>Hand drawing of block diagram (Figure 2)</li>
				<li>Began planning software event handlers and user stories</li>
				<li>Visited Joe to enquire about wireless networking, discovered that Wifi connectivity would be the best option for us to start with</li>
				<li>Acquired three wifi modules</li>
			</ul>
			<h5>Figures</h5> 
			<div style="margin: auto; text-align: center; ">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/bd.png"></img><br>
				<b>Figure 1:</b> Digital version of our project's high level block diagram
			</div>
			<br><br>
			<div style="margin: auto; text-align: center;">
				<img style="width: 50%; border: solid;" src="Team/progress/img/jon/hand_bd.jpg"></img><br>
				<b>Figure 2:</b> Hand drawn, first iteration of high level block diagram
			</div>
            <br>

            
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
